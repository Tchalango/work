Nickel â€” ton screenshot montre que **le pipeline tourne pour de vrai** sur `dcomp.dll` et quâ€™il a dÃ©jÃ  sorti une **premiÃ¨re â€œcarteâ€ dâ€™angles dâ€™attaque** :

* **A001 (189)** = â€œvirtual dispatch sans validationâ€ â†’ trÃ¨s frÃ©quent â†’ souvent beaucoup de bruit, mais Ã§a sert Ã  trouver les zones OO chaudes.
* **B002 (2)** = `PropVariantClear/Copy` â†’ rare â†’ **trÃ¨s bon candidat Ã  triager en premier**.
* **B005 (5)** = `CoCreateInstance/CoGetClassObject` â†’ intÃ©ressant (COM/factories) â†’ Ã  vÃ©rifier si CLSID/IID ou chemins dâ€™erreur mal gÃ©rÃ©s.

Je te donne maintenant un **plan dâ€™actions + commandes** pour passer de â€œjâ€™ai un reportâ€ Ã  â€œjâ€™ai 2-3 sites P1 Ã  regarderâ€.

---

## 1) Fixe les variables (copier-coller)

Adapte juste le dossier `OUT` si besoin.

```bash
TC_HOME="$HOME/type_confusing"
OUT="$TC_HOME/output/dcomp_final1"

# projet ghidra crÃ©Ã© par ton wrapper (souvent: projects/<name>_project)
PROJ="$TC_HOME/projects/dcomp_project"
NAME="dcomp"
BIN="/mnt/c/Windows/System32/dcomp.dll"
```

---

## 2) Regarde la forme exacte de `findings.json` (1 commande)

Ã‡a Ã©vite de deviner les champs (pattern/category/etc.).

```bash
jq 'keys' "$OUT/findings.json"
jq '.findings[0]' "$OUT/findings.json" | sed -n '1,80p'
```

---

## 3) Extraire **B002** (PropVariant) + **B005** (COM) (commande robuste)

MÃªme si tes champs sâ€™appellent `pattern` ou `category`, Ã§a marche parce quâ€™on matche au texte.

```bash
# B002: PropVariant
jq -r '
  .findings[]
  | select(((.pattern // .category // .id // "")|tostring|test("B002|PropVariant";"i")))
  | "\(.address) | \(.function // "unknown") | \(.api // .title // "n/a")"
' "$OUT/findings.json"

# B005: COM create
jq -r '
  .findings[]
  | select(((.pattern // .category // .id // "")|tostring|test("B005|CoCreateInstance|CoGetClassObject";"i")))
  | "\(.address) | \(.function // "unknown") | \(.api // .title // "n/a")"
' "$OUT/findings.json"
```

ğŸ‘‰ Objectif : avoir **les 2 adresses B002** et les **5 adresses B005**.

---

## 4) Inspect automatique des adresses (gÃ©nÃ¨re des fichiers texte)

Ã‡a te sort le **code dÃ©compilÃ© + instructions autour** sans GUI (parfait sur tunnel).

### Inspect B002 (prioritÃ© #1)

```bash
mkdir -p "$OUT/inspect"

jq -r '
  .findings[]
  | select(((.pattern // .category // .id // "")|tostring|test("B002|PropVariant";"i")))
  | .address
' "$OUT/findings.json" \
| while read -r ADDR; do
    echo "[*] Inspect $ADDR"
    "$GHIDRA_HOME/support/analyzeHeadless" \
      "$PROJ" "$NAME" \
      -process "$(basename "$BIN")" \
      -noanalysis \
      -scriptPath "$TC_HOME/scripts" \
      -postScript inspect_address.py "$ADDR" \
      > "$OUT/inspect/B002_${ADDR//:/_}.txt" 2>&1
  done
```

### Inspect B005 (COM)

```bash
jq -r '
  .findings[]
  | select(((.pattern // .category // .id // "")|tostring|test("B005|CoCreateInstance|CoGetClassObject";"i")))
  | .address
' "$OUT/findings.json" \
| while read -r ADDR; do
    echo "[*] Inspect $ADDR"
    "$GHIDRA_HOME/support/analyzeHeadless" \
      "$PROJ" "$NAME" \
      -process "$(basename "$BIN")" \
      -noanalysis \
      -scriptPath "$TC_HOME/scripts" \
      -postScript inspect_address.py "$ADDR" \
      > "$OUT/inspect/B005_${ADDR//:/_}.txt" 2>&1
  done
```

---

## 5) Comment dÃ©cider â€œP1 exploitableâ€ en 2 minutes par fichier

### Pour **B002 PropVariant**

Dans chaque `B002_*.txt`, cherche :

* est-ce que le code **lit un champ union** (`pwszVal`, `bstrVal`, `ulVal`, `punkVal`, etc.) ?
* est-ce quâ€™il y a un check clair du tag (`vt`) **juste avant** ?
* est-ce que Ã§a vient dâ€™un flux externe (property store, metadata, parsing) ?

Commande pour repÃ©rer vite :

```bash
grep -nEi "vt|V_VT|PropVariant|pwsz|bstr|punk|ulVal|llVal" "$OUT/inspect"/B002_*.txt | head -n 80
```

### Pour **B005 COM**

Tu cherches :

* CLSID/IID dâ€™oÃ¹ ils viennent (constants vs input)
* HRESULT checkÃ© ?
* usage du pointeur retournÃ© : cast/virtual call juste aprÃ¨s ?

```bash
grep -nEi "CoCreateInstance|CoGetClassObject|CLSID|IID|hresult|SUCCEEDED|FAILED|QueryInterface" \
  "$OUT/inspect"/B005_*.txt | head -n 120
```

---

## 6) Et A001 (189) ? (comment le rendre utile sans te noyer)

A001 en masse = normal sur une DLL C++.

Ce que tu veux faire :

* **cluster par fonction** â†’ tu priorises les fonctions qui ont 5â€“20 occurrences (souvent des dispatchers), puis tu regardes celles oÃ¹ lâ€™objet vient de parsing.

Exemple (si tes champs le permettent) :

```bash
jq -r '
  .findings[]
  | select(((.pattern // .category // .id // "")|tostring|test("A001|Virtual dispatch";"i")))
  | (.function // "unknown")
' "$OUT/findings.json" | sort | uniq -c | sort -nr | head -n 30
```

---

## Ce que je te propose maintenant

Ouvre juste **un** des fichiers gÃ©nÃ©rÃ©s :

* `output/dcomp_final1/inspect/B002_....txt`

Copie/colle ici le bloc **DECOMPILED CODE** + 20 lignes autour (ou colle le fichier entier si tu veux), et je te fais la lecture â€œreview vulnâ€ :

* oÃ¹ est lâ€™input,
* quel check manque,
* quelle hypothÃ¨se de type confusion tester en premier.
