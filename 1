Nickel — tes screenshots montrent que tu as fait **exactement** les deux fixes qui débloquent le triage “pro” :

1. **Validation MSVC VFTABLE (COL sig = 1)** → tu filtres les faux positifs type `WindowsDeleteString`
2. **CallChainAnalyzer** → tu remontes jusqu’à un “entrypoint” même si c’est une **entrée vtable/callback**

Et là ton résultat important :

* **B002 = FUN_180107f28** (parsing PROPVARIANT)
* **Entry point = FUN_1801091f0**
* **FUN_1801091f0 n’a pas de callers directs** → normal : c’est appelé via **virtual dispatch** (vtable)
* **Référencé depuis vtables 0x1801abe10 et 0x180204454** → donc c’est **un slot de méthode** dans au moins 2 vtables (souvent interface + dérivation / multiple interface / thunk)

---

## 1) Commande “test réel” sur un EXE Windows (depuis WSL2)

Choisis un exe simple et stable :

### Option A (simple) : Notepad

```bash
cd ~/type_confusing   # ou ~/type_confusion selon ton repo
./scripts/run_analysis.sh "/mnt/c/Windows/System32/notepad.exe" "output/notepad_run1"
```

### Option B : cmd.exe (encore plus “classique”)

```bash
cd ~/type_confusing
./scripts/run_analysis.sh "/mnt/c/Windows/System32/cmd.exe" "output/cmd_run1"
```

Après :

```bash
cat output/notepad_run1/report.md | sed -n '1,120p'
jq '.stats.by_risk' output/notepad_run1/patterns.json
```

Si tu veux éviter les effets “projet Ghidra déjà existant” :

```bash
rm -rf projects/notepad_project 2>/dev/null
```

---

## 2) Maintenant, comment exploiter ton nouveau signal “entrypoint via vtable” (sans perdre du temps)

### Étape 1 — Identifier **quelle classe / interface** correspond à ces vtables

Tu as déjà `rtti.json`. Donc :

```bash
OUT="output/dcomp_final1"   # adapte
jq '.vtables[] | select(.address=="0x1801abe10" or .address=="0x180204454") | {vtable:.address,class:.class,entry_count:.entry_count}' \
  "$OUT/rtti.json"
```

### Étape 2 — Trouver **le slot (index)** de `FUN_1801091f0` dans la vtable

Si ton `rtti.json` stocke aussi les entries avec leur adresse :

```bash
jq --arg f "0x1801091f0" '
  .vtables[]
  | select(any(.entries[]; .address==$f))
  | { vtable:.address,
      class:.class,
      slot:(.entries[] | select(.address==$f) | .index),
      name:(.entries[] | select(.address==$f) | .name)
    }' "$OUT/rtti.json"
```

**Résultat attendu :**

* tu obtiens un `slot` (genre 7, 12, 19…) → c’est **LA méthode** qui mène au parsing
* * le nom si Ghidra l’a résolu

### Étape 3 — Trouver où l’objet est créé (constructeur / factory / COM activation)

Ton callchain dit “attaque surface via COM/vtable”, donc le vrai next step c’est :

* **Qu’est-ce qui instancie l’objet qui possède ces vtables ?**
* **Quel est l’appel “haut niveau”** qui finit par appeler ce slot ?

Commandes rapides utiles :

1. Chercher des fonctions qui écrivent le vptr (constructeurs) : dans Ghidra ça revient à trouver les xrefs vers l’adresse de vtable **en data**.
   Si tu as déjà un script “xref vtable”, lance-le sur `0x1801abe10` et `0x180204454` et récupère les fonctions qui font le `mov [rcx], vtable`.

2. Inspecter `FUN_1801091f0` :

```bash
$GHIDRA_HOME/support/analyzeHeadless \
  projects/dcomp_project dcomp \
  -process dcomp.dll \
  -noanalysis \
  -scriptPath scripts \
  -postScript inspect_address.py 0x1801091f0 \
  > "$OUT/inspect/inspect_FUN_1801091f0.txt" 2>&1

grep -nEi "rcx|this|vt|variant|propvariant|stream|buffer|size|length|memcpy|copy" \
  "$OUT/inspect/inspect_FUN_1801091f0.txt" | head -n 200
```

**Résultat attendu :**

* tu vois si le “buffer interne” vient en fait d’un param, d’un stream, d’un état objet, etc.

---

## 3) Lecture “dev” de ton état actuel (ce que ça veut dire)

* Tu n’as pas “un export vulnérable” → tu as **une méthode d’interface** appelée via un objet.
* Donc le sujet n’est plus “où est le bug”, mais “**reachability**” :

  * comment obtenir une instance de l’objet ?
  * quelle API / COM / message / pipeline l’appelle ?
  * est-ce que l’input qui remplit le `PROPVARIANT` est influençable ?

Et avec ton nouveau tooling, tu es à **2 commandes** de la réponse :

* slot index dans vtable
* xrefs vers la vtable (constructeur/factory)

---

Si tu me donnes (copie/colle texte) :

* la sortie des 2 commandes `jq` ci-dessus (classe + slot),
  je te dis **quoi inspecter exactement ensuite** (le meilleur “entrypoint haut niveau” à remonter en premier) et **comment décider vite** si B002 est atteignable ou juste du parsing interne “non input-driven”.
