Parfait â€” ton triage est exactement ce que tu veux voir : **B002 (2 hits)** sort du lot, **B005 (5 hits)** ensuite, et **A001** sert surtout Ã  â€œpointer les zones OO chaudesâ€ (vtable 0x1801bba90).

Je te donne maintenant **les commandes concrÃ¨tes** pour passer en â€œvraie analyseâ€ (headless, tunnel) sur ces 3 axes.

---

## 0) Variables (copie-colle)

Adapte juste si ton path est diffÃ©rent.

```bash
TC_HOME="/home/PC/type_confusing"
OUT="$TC_HOME/output/dcomp_final1"
BIN="/mnt/c/Windows/System32/dcomp.dll"

# Trouver automatiquement le projet Ghidra utilisÃ©
PROJ="$(ls -d "$TC_HOME"/projects/*dcomp* 2>/dev/null | head -n 1)"
NAME="dcomp"

echo "PROJ=$PROJ"
ls -la "$OUT"
```

> Si `PROJ` est vide, liste tes projets : `ls -la $TC_HOME/projects`

---

## 1) Extraire les 2 adresses B002 + les 5 B005 depuis findings.json

Ton rÃ©sumÃ© montre â€œB002 / B005â€, donc on filtre large (code/pattern/category).

```bash
# B002
jq -r '
  .findings[]
  | select(((.code // .pattern // .category // .id // "")|tostring|test("B002|PropVariant";"i")))
  | .address
' "$OUT/findings.json" | nl

# B005
jq -r '
  .findings[]
  | select(((.code // .pattern // .category // .id // "")|tostring|test("B005|CoCreateInstance|CoGetClassObject";"i")))
  | .address
' "$OUT/findings.json" | nl
```

---

## 2) Inspect automatique des sites B002 (prioritÃ© #1)

Ã‡a te sort des fichiers texte avec **dÃ©compilation + instructions**.

```bash
mkdir -p "$OUT/inspect"

jq -r '
  .findings[]
  | select(((.code // .pattern // .category // .id // "")|tostring|test("B002|PropVariant";"i")))
  | .address
' "$OUT/findings.json" \
| while read -r ADDR; do
    echo "[*] Inspect B002 at $ADDR"
    "$GHIDRA_HOME/support/analyzeHeadless" \
      "$PROJ" "$NAME" \
      -process "$(basename "$BIN")" \
      -noanalysis \
      -scriptPath "$TC_HOME/scripts" \
      -postScript inspect_address.py "$ADDR" \
      > "$OUT/inspect/B002_${ADDR//:/_}.txt" 2>&1
  done

ls -áƒšáƒ "$OUT/inspect"/B002_*.txt
```

### Lecture rapide â€œest-ce chaud ?â€

```bash
grep -nEi "vt|V_VT|PropVariant|pwsz|bstr|punk|ulVal|llVal|byref|union" \
  "$OUT/inspect"/B002_*.txt | head -n 120
```

---

## 3) Inspect direct de la fonction â€œFUN_180107f28â€ (si câ€™est lâ€™entrÃ©e)

Dans ton report, il parle de `FUN_180107f28`. Ã‡a correspond gÃ©nÃ©ralement Ã  **lâ€™adresse 0x180107f28**.

```bash
"$GHIDRA_HOME/support/analyzeHeadless" \
  "$PROJ" "$NAME" \
  -process "$(basename "$BIN")" \
  -noanalysis \
  -scriptPath "$TC_HOME/scripts" \
  -postScript inspect_address.py 0x180107f28 \
  > "$OUT/inspect/FUN_180107f28.txt" 2>&1

sed -n '1,220p' "$OUT/inspect/FUN_180107f28.txt"
```

---

## 4) Identifier â€œqui estâ€ la vtable 0x1801bba90 via rtti.json

Tu veux associer **vtable â†’ classe + mÃ©thodes**.

```bash
VT="0x1801bba90"

jq -r --arg VT "$VT" '
  .vtables[]
  | select(.address==$VT)
  | {address, class, offset_in_object, entry_count, first_entries: (.entries[0:25])}
' "$OUT/rtti.json"
```

Si Ã§a ne ressort rien (parfois format/leading zeros), essaye en â€œcontainsâ€ :

```bash
jq -r '
  .vtables[]
  | select(.address|ascii_downcase|contains("1801bba90"))
  | {address, class, offset_in_object, entry_count}
' "$OUT/rtti.json"
```

---

## 5) Trouver toutes les xrefs vers cette vtable (ultra utile)

CrÃ©e un mini script Ghidra headless `xrefs_to.py` (1 fois), puis tu lâ€™appelles pour 0x1801bba90.

### Script `xrefs_to.py`

```bash
cat > "$TC_HOME/scripts/xrefs_to.py" << 'PY'
# xrefs_to.py
# @category TypeConfusion
# @description Print XRefs to an address (data/code) with containing function
# Usage: -postScript xrefs_to.py 0x1801bba90

def main():
    args = getScriptArgs()
    if not args:
        print("Usage: -postScript xrefs_to.py <hex_address>")
        return

    addr_str = args[0]
    target = int(addr_str, 16) if addr_str.startswith("0x") else int(addr_str)

    fm = currentProgram.getFunctionManager()
    rm = currentProgram.getReferenceManager()
    space = currentProgram.getAddressFactory().getDefaultAddressSpace()
    a = space.getAddress(target)

    print("XREFS TO: {}".format(a))
    refs = rm.getReferencesTo(a)

    count = 0
    for r in refs:
        count += 1
        fa = r.getFromAddress()
        f = fm.getFunctionContaining(fa)
        fn = f.getName() if f else "N/A"
        print("  {}  from {}  in {}  type={}".format(count, fa, fn, r.getReferenceType()))
        if count >= 200:
            print("  ... truncated")
            break

main()
PY
```

### Appel pour la vtable

```bash
"$GHIDRA_HOME/support/analyzeHeadless" \
  "$PROJ" "$NAME" \
  -process "$(basename "$BIN")" \
  -noanalysis \
  -scriptPath "$TC_HOME/scripts" \
  -postScript xrefs_to.py 0x1801bba90 \
  > "$OUT/inspect/xrefs_vtable_1801bba90.txt" 2>&1

sed -n '1,200p' "$OUT/inspect/xrefs_vtable_1801bba90.txt"
```

---

## 6) B005 (COM) : est-ce que IID/CLSID sont contrÃ´lables ?

MÃªme mÃ©thode : inspect les 5 sites puis grep.

```bash
jq -r '
  .findings[]
  | select(((.code // .pattern // .category // .id // "")|tostring|test("B005|CoCreateInstance|CoGetClassObject";"i")))
  | .address
' "$OUT/findings.json" \
| while read -r ADDR; do
    echo "[*] Inspect B005 at $ADDR"
    "$GHIDRA_HOME/support/analyzeHeadless" \
      "$PROJ" "$NAME" \
      -process "$(basename "$BIN")" \
      -noanalysis \
      -scriptPath "$TC_HOME/scripts" \
      -postScript inspect_address.py "$ADDR" \
      > "$OUT/inspect/B005_${ADDR//:/_}.txt" 2>&1
  done

grep -nEi "CoCreateInstance|CoGetClassObject|IID|CLSID|GUID|hresult|SUCCEEDED|FAILED|QueryInterface" \
  "$OUT/inspect"/B005_*.txt | head -n 200
```

**Ce que tu veux voir :**

* `rclsid` / `riid` = constantes (OK, moins intÃ©ressant)
* ou dÃ©rivent dâ€™un buffer / param / property (ğŸ”¥)

---

# Ordre â€œcomme un chef de projetâ€ (ce que tu fais maintenant)

1. **B002** : ouvre un `B002_*.txt` et repÃ¨re si `vt` est checkÃ© avant dâ€™utiliser lâ€™union
2. **FUN_180107f28** : comprends le flux (dâ€™oÃ¹ vient le PROPVARIANT)
3. **vtable 0x1801bba90** : map RTTI + xrefs (Ã§a te donne les â€œconsommateursâ€ principaux)
4. **B005** : vÃ©rifie si IID/CLSID viennent dâ€™ailleurs que des constantes

---

Si tu veux quâ€™on avance â€œen mode reviewâ€, colle ici **le contenu de** :

* `OUT/inspect/B002_....txt` (au moins la section *DECOMPILED CODE* + 30 lignes),
  ou mÃªme juste `grep -n "DECOMPILED" -n` + le bloc autour,

et je te dis **si câ€™est P1/P2/bruit** et exactement quoi tracer ensuite (caller chain, vt-check, etc.).
